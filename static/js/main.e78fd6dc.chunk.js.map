{"version":3,"sources":["ShowTime.js","Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","index.js"],"names":["React","Component","Todoinput","handleInput","e","keyCode","props","add","target","value","handleChange","setState","name","parseInt","bind","state","a","b","c","console","log","this","refs","focus","ref","onChange","onKeyDown","type","inp","onClick","Todoing","delI","idx","del","todo","map","item","key","defaultProps","Todolist","addItem","data","delItem","splice","ReactDOM","render","document","getElementById"],"mappings":"mMAQuBA,IAAMC,U,6BCJRC,E,YACjB,aAAc,IAAD,8BACT,+CAQJC,YAAc,SAACC,GAKM,KAAdA,EAAEC,SACD,EAAKC,MAAMC,IAAIH,EAAEI,OAAOC,QAfnB,EAkBbC,aAAe,SAACN,GACZ,EAAKO,SAAL,eACKP,EAAEI,OAAOI,KAAOC,SAA2B,KAAlBT,EAAEI,OAAOC,MAAc,EAAIL,EAAEI,OAAOC,UAlBlE,EAAKN,YAAc,EAAKA,YAAYW,KAAjB,gBACnB,EAAKC,MAAQ,CACTC,EAAE,GACFC,EAAE,GACFC,EAAE,IANG,E,iFAyBTC,QAAQC,IAAIC,KAAKC,KAAKN,GACtBK,KAAKC,KAAKN,EAAEO,U,+BAEN,IAAD,OACL,OACI,6BAOI,2BAAOC,IAAI,IAAIZ,KAAK,IAAIa,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAMC,EAAGU,UAAWL,KAAKlB,YAAawB,KAAK,SAPhH,IASI,2BAAOf,KAAK,IAAIa,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAME,EAAGS,UAAWL,KAAKlB,YAAawB,KAAK,SATxG,IAWI,2BAAOf,KAAK,IAAIa,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAMG,EAAGQ,UAAWL,KAAKlB,YAAawB,KAAK,SAXxG,IAaI,2BAAIN,KAAKN,MAAMC,EAAEK,KAAKN,MAAME,EAAEI,KAAKN,MAAMG,GAEzC,2BAAOM,IAAK,SAACI,GAAD,OAAO,EAAKA,IAAIA,GAAKD,KAAK,SAEtC,4BAAQE,QAAS,WAAKV,QAAQC,IAAI,EAAKQ,IAAInB,SAA3C,qB,GAhDuBR,aCDlB6B,E,2MACjBC,KAAK,SAACC,GAGF,EAAK1B,MAAM2B,IAAID,I,wEAET,IAAD,OACAE,EAAQb,KAAKf,MAAb4B,KACL,OACI,6BACI,4BAGIA,EAAKC,KAAI,SAACC,EAAKJ,GAAN,OAAc,wBAAIK,IAAKL,GAAMI,EAAf,MAAuB,4BAAQP,QAAS,EAAKE,KAAKjB,KAAK,EAAKkB,IAArC,0B,GAb7B/B,aA+BrC6B,EAAQQ,aAAe,CACnBJ,KAAM,CAAC,EAAE,EAAE,EAAE,I,IC9BIK,E,YACjB,aAAc,IAAD,8BACT,+CAoBJC,QAAU,SAACC,GACPtB,QAAQC,IAAIqB,GAGZ,EAAK9B,SAAS,CAGVuB,KAAK,GAAD,mBAAM,EAAKnB,MAAMmB,MAAjB,CAAsBO,OA5BrB,EA+BbC,QAAU,SAACV,GAEP,IAAIE,EAAI,YAAO,EAAKnB,MAAMmB,MAC1BA,EAAKS,OAAOX,EAAI,GAEhB,EAAKrB,UAAS,SAACI,EAAMT,GAGjB,OADAa,QAAQC,IAAIL,EAAMmB,MACX,CAACA,KAAKA,OArCjB,EAAKnB,MAAQ,CACTmB,KAAM,CAAC,EAAE,EAAE,IAHN,E,sEAkDT,OACI,6BAEI,kBAAC,EAAD,CAAW3B,IAAKc,KAAKmB,UACrB,kBAAC,EAAD,CAASP,IAAKZ,KAAKqB,QAASR,KAAMb,KAAKN,MAAMmB,Y,GAvDvBjC,aCOtC2C,IAASC,OAAO,kBAAC,EAAD,MAAaC,SAASC,eAAe,U","file":"static/js/main.e78fd6dc.chunk.js","sourcesContent":["import React, { Fragment } from 'react';\r\n\r\n//子组件\r\n\r\n\r\n//用类来构建组件(能不用就不用)\r\n//用继承来定义\r\n// class ShowTime extends Component如果要写成这样，必须在头部引入import React,{Fragment,Component} from 'react';。否则只能写成下示方式：\r\nclass ShowTime extends React.Component {\r\n    constructor() {\r\n        super(); //这个必须位于整个方法内部的第一行\r\n        this.state = {\r\n            time: new Date().toLocaleString(),\r\n            a: 100,\r\n            b: 200\r\n        };\r\n        console.log(\"constructor\");\r\n        setInterval(() => {\r\n            this.setState({\r\n                time: new Date().toLocaleString()\r\n            });\r\n        }, 1000);\r\n    }\r\n    shouldComponentUpdate() {\r\n        if (this.state.a > 10) {\r\n            // 满足条件时更新，否则不更新\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    componentDidUpdate(prePprps, preState, data) {\r\n        console.log(\"didupdate\");\r\n        console.log(preState);\r\n        console.log(this.state.time);\r\n    }\r\n    getSnapshotBeforeUpdate() {\r\n        console.log(\"getSnapshot\");\r\n        return { name: this.state.a };\r\n    }\r\n    componentDidMount() {\r\n        console.log('didmount'); //组件运行完了之后才会执行didmount\r\n    }\r\n    render() {\r\n        console.log(\"render\");\r\n        var { name, age } = this.props; //因为引入了这个，所以在引用name时不必再用this.props.name\r\n        return (<Fragment>\r\n\r\n            {name.length > 5 ? <div>姓名：{name}</div> : ''}\r\n\r\n            <div>{this.state.time}</div>\r\n            <div>\r\n                {age.map((item, index) => {\r\n                    if (index % 2 === 0) {\r\n                        return <p key={index}>{item}</p>;\r\n                    }\r\n                })}\r\n            </div>\r\n        </Fragment>);\r\n    }\r\n}\r\n\r\n//默认导出：只能导出一次，也就是只能有一个export。被引入这个组件时，可以重命名\r\n// export default ShowTime;\r\n\r\n//命名导出：不能重命名，但是必须加上大括号\r\nexport {ShowTime};\r\n","import React, { Component } from 'react'\r\n// 受控组件：value值被react控制的表单元素\r\n// 可以实时获取表单元素的值（表单验证）/写法相对麻烦\r\n// \r\nexport default class Todoinput extends Component {\r\n    constructor(){\r\n        super();\r\n        this.handleInput = this.handleInput.bind(this);\r\n        this.state = {\r\n            a:'',\r\n            b:'',\r\n            c:''\r\n        }\r\n    }\r\n    handleInput = (e)=>{\r\n        //用箭头函数改变this的指向，使this指向正确。\r\n        //利用箭头函数之后就不用再从constructor中写入this.handleInput = this.handleInput.bind(this);\r\n        //函数声明\r\n        //绑定this，事件处理函数写成箭头函数，或者用bind\r\n        if(e.keyCode === 13){\r\n            this.props.add(e.target.value);\r\n        }\r\n    }\r\n    handleChange = (e)=>{\r\n        this.setState({\r\n            [e.target.name]: parseInt(e.target.value ==='' ? 0 : e.target.value)\r\n        })\r\n    }\r\n    componentDidMount(){\r\n        //这个函数是在render执行完之后执行的\r\n        console.log(this.refs.a);\r\n        this.refs.a.focus();//这样写并且加上下边第一个input标签中的ref='a'等价于ref={(inp)=>{this.a=inp}}\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                {/* 将handleInput函数赋给input标签 */}\r\n                {/* 受控组件：value值被react空值的表单元素，这里value就叫做受控组件。\r\n                     要想改变该组件，通过在input上添加value属性和onChange属性，\r\n                     并且在constructor中设置this.state，同时在这个类中添加handleChange方法 */}\r\n                {/*受控组件： value=\"abc\"设置value值之后，就再也没法对input框进行输入了 */} \r\n                {/*（写法麻烦） 改变受控组件的好处：你可以实时获取表单元素的的值(表单验证：没输入一个字符就要进行提示，可以通过改过的受控组件来实现) */}\r\n                <input ref='a' name=\"a\" onChange={this.handleChange} value={this.state.a} onKeyDown={this.handleInput} type=\"text\"/>\r\n                +\r\n                <input name=\"b\" onChange={this.handleChange} value={this.state.b} onKeyDown={this.handleInput} type=\"text\"/>\r\n                +\r\n                <input name=\"c\" onChange={this.handleChange} value={this.state.c} onKeyDown={this.handleInput} type=\"text\"/>\r\n                =\r\n                <p>{this.state.a+this.state.b+this.state.c}</p>\r\n                {/* 非受控组件: 一次性想获取或处理表单元素的值 */}\r\n                <input ref={(inp)=>this.inp=inp} type=\"text\"/>\r\n                {/* 当点击提交时，this.inp会返回这个input节点，this.inp.value会返回输入的值 */}\r\n                <button onClick={()=>{console.log(this.inp.value)}}>提交</button>\r\n            </div>\r\n        )\r\n        \r\n    }\r\n}\r\n//受控组件：\r\n// 1、给input标签添加value属性，赋值为state的值\r\n// 2、给input标签绑定onChange事件，在事件处理函数中setState\r\n// 3、一个事件处理函数控制多个表单元素时，给input标签加上name属性，事件处理函数中写：\r\n//     setState = ({\r\n//         [e.target.name]: e.target.value\r\n//     })","import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';//\r\n\r\nexport default class Todoing extends Component {\r\n    delI=(idx)=>{\r\n        //直接调用父组件里边的del属性所指向的方法,然后调用delItem方法\r\n        //这个函数是用于和button里边的bind方法相对应的，和Todolist.js里边的delItem函数没有关系\r\n        this.props.del(idx);\r\n    }\r\n    render() {\r\n        var {todo} = this.props;\r\n        return (\r\n            <div>\r\n                <ul>{\r\n                    // 不用bind，用箭头函数，函数需要传参的时候这样写： onClick={(e)=>this.props.del(idx,e)}\r\n                    // 不用bind，用箭头函数，函数不需要传参的时候这样写： onClick={this.props.del}\r\n                    todo.map((item,idx) => <li key={idx}>{item}---<button onClick={this.delI.bind(this,idx)}>删除</button></li>)\r\n                    //将箭头函数写成上述形式，是因为：箭头函数直接返回了一个值，可以省略大括号和return，直接只想要返回的值就行；\r\n                    //如果箭头函数中还包括了其他的逻辑，就应该用大括号和return，用return返回最后想要得到的东西\r\n                }</ul>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n//定义类型,传入的值要和定义的这个类型相对应，否则会报错\r\n//PropTypes.element表示React元素\r\nTodoing.propTypes = {\r\n    todo: PropTypes.array,\r\n    del: PropTypes.func,\r\n    add: PropTypes.func\r\n}\r\n\r\n//设置默认值，防止在你未传入属性值的时候报错，当你传入属性值之后这个就无效了\r\nTodoing.defaultProps = {\r\n    todo: [1,1,1,1]\r\n}","//输入rcc可以直接出来一个代码结构\r\nimport React, { Component } from 'react'\r\nimport Todoinput from './Todoinput'\r\nimport Todoing from './Todoing'\r\n\r\nexport default class Todolist extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            todo: [1,2,3],\r\n        }\r\n\r\n        // 深拷贝/浅拷贝\r\n        // var obj = {a:100,b:[1,2,3]};\r\n        // var obj1 = {c:300};\r\n        // var o = {...obj};//a还是100\r\n        // var o = obj;//a变成了200,引用赋值，a发生改变\r\n        // var o = Object.assign(obj,obj1);//把obj1上的属性都转到了obj上\r\n        // var o = JSON.parse(JSON.stringify(obj));//转换成字符串，又转换成了对象\r\n        // o.a = 200;\r\n        // o.b[0] = 2000000;\r\n        // console.log(Object.keys(obj));//obj的属性名组成的数组\r\n        // Object.keys(obj).forEach((item) => {//keys方法必须掌握，还有forEach以后也常用\r\n        //     console.log(item);//属性名\r\n        //     console.log(obj[item]);//属性值\r\n        // })\r\n    }\r\n    addItem = (data) => {//将这个箭头函数赋值给addItem，这样addItem也就变成了一个函数\r\n        console.log(data);\r\n        // this.state.todo.push(data);能push上去，但是没有办法显示出来\r\n        // console.log(...this.state.todo)输出1 2 3\r\n        this.setState({\r\n            //setState是你定位到哪想改哪一个就改的是哪一个，改完之后的元素会和原来的元素重新组合，变成一个新的\r\n            // 利用js学过的展开运算符，连接原来的旧的元素和现在传入的新的元素\r\n            todo: [...this.state.todo,data]\r\n        })\r\n    }\r\n    delItem = (idx) => {\r\n        //1、不能直接改变或处理state，只能通过setState改变或处理\r\n        let todo = [...this.state.todo];//相当于拷贝\r\n        todo.splice(idx,1);//第一个参数是要删除元素的开始位置，第二个参数表示要删除元素的个数\r\n        //2、setState是异步执行的\r\n        this.setState((state,props)=>{\r\n            //这样（用箭头函数）写能保证你可以一直获得更改之前的那个值，但是下边那种方法不能保证你可以得到你想要的数据\r\n            console.log(state.todo);\r\n            return {todo:todo}\r\n        })\r\n        // this.setState({\r\n            //在setState里获取state可能会出错，不是你想要的结果，那你就可以用上面那种方式\r\n        //     todo: todo\r\n        // },()=>{\r\n        //     console.log(this.state.todo);\r\n        // })\r\n        // console.log(this.state.todo);//先执行这个，才会执行setState\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                {/* Todolist这个父组件调用Todoinput这个子组件，而子组件通过add调用了addItem这个方法 */}\r\n                <Todoinput add={this.addItem}/>\r\n                <Todoing del={this.delItem} todo={this.state.todo}/>\r\n\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React,{Fragment} from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport {ShowTime} from './ShowTime';\nimport { directive, thisExpression } from '@babel/types';\nimport Todolist from './Todolist/Todolist';\n\n//父组件\n\n\n//组件交互\n//父组件---->子组件：调用子组件时添加属性，子组件通过props拿到传递的数据\nReactDOM.render(<Todolist />,document.getElementById('root'))\n\n//子组件---->父组件：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/********************************************  React基础语法-元素渲染、组件-2019/10/12    */\n// //函数声明组件\n// function ShowTime(props){\n//     console.log(props);\n//     //return只能返回一个对象\n//     //这样将return返回的值用<Fragment></Fragment>包起来并在头部引入import React,{Fragment} from 'react';，就不会再因为传的参数多于一个而报错\n//     return (<Fragment>\n//                 <div>{props.name}{props.age}</div>\n//                 <div>{new Date().toLocaleString()}</div>\n//             </Fragment>);//这里最后必须返回一个js代码\n//     //但凡遇到有显示变量的地方，都需要将变量用{}包起来\n// }\n\n\n// //用类来构建组件(能不用就不用)——————————这一部分作为子组件，写在了ShowTime.js文件中\n// //用继承来定义\n// // class ShowTime extends Component如果要写成这样，必须在头部引入import React,{Fragment,Component} from 'react';。否则只能写成下示方式：\n// class ShowTime extends React.Component{\n//     constructor(){//这是一个生命周期，会自动执行了，但是自己定义的类不会自动执行，只有调用的时候才会执行\n//         super();//这个必须位于整个方法内部的第一行\n//         this.state = {\n//             time:new Date().toLocaleString(),\n//             a:100,\n//             b:200\n//         }\n//         console.log(\"constructor\");\n//         setInterval(() => {//用setState来实现实时更新时间（setState方法存在于Component类中）\n//             this.setState({\n//                 time:new Date().toLocaleString()\n//             })\n//         },1000)\n//     }\n//     shouldComponentUpdate(){\n//         if(this.state.a>10){\n//             // 满足条件时更新，否则不更新\n//             return true;\n//         }\n//         else{\n//             return false;\n//         }\n\n//     }\n//     componentDidUpdate(prePprps,preState,data){\n//         console.log(\"didupdate\");\n//         console.log(preState);\n//         console.log(this.state.time);\n//     }\n//     getSnapshotBeforeUpdate(){\n//         console.log(\"getSnapshot\");\n//         return {name:this.state.a};\n//     }\n//     componentDidMount(){\n//         console.log('didmount');//组件运行完了之后才会执行didmount\n//     }\n//     render(){//自动执行了\n//         console.log(\"render\");\n//         var {name,age} = this.props;//因为引入了这个，所以在引用name时不必再用this.props.name\n//         return (\n//             <Fragment>\n//                 {/* 条件渲染 */}\n//                 {name.length>5 ? <div>姓名：{name}</div> : ''}\n//                 {/* 上述可以写成： {name.length>5 && <div>姓名：{name}</div>}*/}\n//                 <div>{this.state.time}</div>\n                \n//                 {/**循环渲染： */}\n//                 <div>\n//                     {\n//                         age.map((item,index) => {\n//                             if(index%2 == 0){\n//                                 return <p key={index}>{item}</p>\n//                             }\n//                         })\n//                     }\n//                 </div>\n//             </Fragment>\n//         )\n//     }\n// }//这一部分作为子组件写在了ShowTime.js文件中\n\n\n// var num =[1,2,3,4,5];\n// ReactDOM.render(\n//     <ShowTime name=\"zhangs\" age={num}/>,//这里传入的参数通过上面的props得到\n//     document.getElementById('root')\n// )\n\n\n// //函数声明组件：\n// // 显示当前系统时间\n//document.querySelector('#root')返回指定的结点，在这里返回root\n// function showTime(){\n//     var ele = <div>{new Date().toLocaleString()}</div>;//要想写这个，必须引入React（import React from 'react';）\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector('#root')\n//     );\n// }\n// showTime();\n\n// //想让它实时显示\n// setInterval(showTime,1000);\n\n\n\n\n\n\n\n\n/***********************************     React基础语法-JSX语法-2019/10/9\n\n// react技术栈\n// jsx语法\n// var ele = <h1 class=\"tit\">hello <p>react</p></h1>;\n// babel编译，返回一个对象\n// var ele = React.createElement(\n//     'h1',元素类型\n//     {id:'tit',class:'title'},元素属性\n//     'hello',元素\n//     React.createElement(\n//         'p',\n//         {id:'t',class:'tit'},\n//         'react')\n// );\n// ReactDOM.render(ele, document.getElementById('root'));\n\nvar obj = {\n    type: 'div',\n    props: {\n        id: 'box',\n        class: 'box',\n        children: [\n            'hello',\n            'react',\n            {\n                type: 'h1',\n                props: {\n                    id: 'tit',\n                    class: 'tit',\n                    children: ['title','react']\n                }\n            }\n        ]\n    }\n}\n//自己封装render函数\nfunction render(obj,container){\n    var {type,props} = obj;\n    // 文档碎片\n    var fragment = document.createDocumentFragment();\n\n    var ele = document.createElement(type);\n    for(var item in props){\n        if(item === 'class'){\n            ele.className = props[item];\n        }else if(item === 'children'){\n            for(var i=0;i<props.children.length;i++){\n                // ele.innerHTML += props.children[i];\n                if(typeof props.children[i] === 'object'){\n                    render(props.children[i],ele);\n                }else{\n                    var txt = document.createTextNode(props.children[i]);\n                    ele.appendChild(txt);\n                }\n            }\n        }else{\n            ele[item] = props[item];\n        }\n    }\n    fragment.appendChild(ele);\n    container.appendChild(fragment);\n}\n// render(obj,document.getElementById('root'));\n\n// 页面渲染过程\n// 请求HTML页面、浏览器HTML解析器解析html文件、生成DOM树\n// link引入css文件、css解析器解析CSS，生成CSS对象模型，CSSD\nOM和DOM tree结合生成一个render tree，最后浏览器绘制页面\n\n// 页面回流（重排reflow）：DOM结构变化、内容变化、大小、位置的变化、显示的变化\n// 页面重绘（repaint）：颜色的变化（背景色、字体颜色、边框颜色）\n\n// 1、先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// var div = document.getElementById('root');\n// var str = ''\n// for(var i=0;i<1000;i++){\n//     str += '<p>'+i+'</p>';\n// }\n// div.innerHTML = str;\n// console.timeEnd('time');\n// 2、对于样式处理,声明一个css类\nvar div = document.getElementById('root');\n// div.style.width = '100px';\n// div.style.height = '100px';\n// div.style.background = 'red';\n\ndiv.className = 'active';\n// 3、offsetLeft、offsetWidth等都会引起回流，要慎用\n// console.log(div.offsetLeft);\n// var wid = div.offsetWidth;\n// setInterval(()=>{\n//     wid += 1;\n//     div.style.width = wid + 'px';\n// },100)\n// 4、文档碎片（内存中的一个变量）\n*/\n"],"sourceRoot":""}